
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pygplates.PolygonOnSphere &#8212; pygplates 2.2.0.28 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="pygplates.GeometryOnSphere" href="pygplates.GeometryOnSphere.html" />
    <link rel="prev" title="pygplates.PolylineOnSphere" href="pygplates.PolylineOnSphere.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="pygplates.GeometryOnSphere.html" title="pygplates.GeometryOnSphere"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="pygplates.PolylineOnSphere.html" title="pygplates.PolylineOnSphere"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">pygplates 2.2.0.28 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../pygplates_reference.html" accesskey="U">Reference</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="pygplates-polygononsphere">
<h1>pygplates.PolygonOnSphere<a class="headerlink" href="#pygplates-polygononsphere" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pygplates.PolygonOnSphere">
<em class="property">class </em><code class="descclassname">pygplates.</code><code class="descname">PolygonOnSphere</code><a class="headerlink" href="#pygplates.PolygonOnSphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere" title="pygplates.GeometryOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.GeometryOnSphere</span></code></a></p>
<p>Represents a polygon on the surface of the unit length sphere. Polygons are equality (<code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>) comparable (but not hashable - cannot be used as a key in a <code class="docutils literal notranslate"><span class="pre">dict</span></code>). See <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> for an overview of equality in the presence of limited floating-point precision.</p>
<p>A polygon instance is both:</p>
<ul class="simple">
<li>a sequence of <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">points</span></code></a> - see <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_points()</span></code>, and</li>
<li>a sequence of <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">segments</span></code></a> (between adjacent points) - see <a class="reference internal" href="#pygplates.PolygonOnSphere.get_segments" title="pygplates.PolygonOnSphere.get_segments"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_segments()</span></code></a>.</li>
</ul>
<p>In addition a polygon instance is <em>directly</em> iterable over its points (without having to use <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_points()</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">polygon</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>…and so the following operations for accessing the points are supported:</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Operation</th>
<th class="head">Result</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">len(polygon)</span></code></td>
<td>number of vertices in <em>polygon</em></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">p</span> <span class="pre">in</span> <span class="pre">polygon</span></code></td>
<td>iterates over the vertices <em>p</em> of <em>polygon</em></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">in</span> <span class="pre">polygon</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>p</em> is equal to a <strong>vertex</strong> of <em>polygon</em></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">polygon</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">False</span></code> if <em>p</em> is equal to a <strong>vertex</strong> of <em>polygon</em></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">polygon[i]</span></code></td>
<td>the vertex of <em>polygon</em> at index <em>i</em></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">polygon[i:j]</span></code></td>
<td>slice of <em>polygon</em> from <em>i</em> to <em>j</em></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">polygon[i:j:k]</span></code></td>
<td>slice of <em>polygon</em> from <em>i</em> to <em>j</em> with step <em>k</em></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">p</span> <span class="pre">in</span> <span class="pre">polygon</span></code> does <strong>not</strong> test whether a point <code class="docutils literal notranslate"><span class="pre">p</span></code> is <em>inside</em> the the <em>interior</em> of a polygon - use <a class="reference internal" href="#pygplates.PolygonOnSphere.is_point_in_polygon" title="pygplates.PolygonOnSphere.is_point_in_polygon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_point_in_polygon()</span></code></a> for that instead.</p>
</div>
<div class="line-block">
<div class="line">Since a <em>PolygonOnSphere</em> is <strong>immutable</strong> it contains no operations or methods that modify its state (such as adding or removing points). This is similar to other immutable types in python such as <code class="docutils literal notranslate"><span class="pre">str</span></code>.</div>
<div class="line">So instead of modifying an existing polygon you will need to create a new <a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolygonOnSphere</span></code></a> instance as the following example demonstrates:</div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get a list of points from an existing &#39;polygon&#39;.</span>
<span class="n">points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>

<span class="c1"># Modify the points list somehow.</span>
<span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>

<span class="c1"># &#39;polygon&#39; now references a new PolygonOnSphere instance.</span>
<span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
</pre></div>
</div>
<p>The following example demonstrates creating a <a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolygonOnSphere</span></code></a> from a <a class="reference internal" href="pygplates.PolylineOnSphere.html#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolylineOnSphere</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="n">polyline</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A polygon closes the loop between its last and first points so there’s no need to make the first and last points equal.</p>
</div>
<dl class="method">
<dt id="pygplates.PolygonOnSphere.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.PolygonOnSphere.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>A <em>PolygonOnSphere</em> object can be constructed in more than one way…</p>
<dl class="docutils">
<dt>__init__(points)</dt>
<dd><p class="first">Create a polygon from a sequence of (x,y,z) or (latitude,longitude) points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param points:</th><td class="field-body">A sequence of (x,y,z) points, or (latitude,longitude) points (in degrees).</td>
</tr>
<tr class="field-even field"><th class="field-name">type points:</th><td class="field-body">Any sequence of <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> or <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><code class="xref py py-class docutils literal notranslate"><span class="pre">LatLonPoint</span></code></a> or tuple (float,float,float) or tuple (float,float)</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body">InvalidLatLonError if any <em>latitude</em> or <em>longitude</em> is invalid</td>
</tr>
<tr class="field-even field"><th class="field-name">raises:</th><td class="field-body">ViolatedUnitVectorInvariantError if any (x,y,z) is not unit magnitude</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body">InvalidPointsForPolygonConstructionError if sequence has less than three points or if any two points (adjacent in the <em>points</em> sequence) are antipodal to each other (on opposite sides of the globe)</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The sequence must contain at least three points in order to be a valid polygon, otherwise <em>InvalidPointsForPolygonConstructionError</em> will be raised.</p>
</div>
<p>During creation, a <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">GreatCircleArc</span></code></a> is created between each adjacent pair of of points in <em>points</em> - see <a class="reference internal" href="#pygplates.PolygonOnSphere.get_segments" title="pygplates.PolygonOnSphere.get_segments"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_segments()</span></code></a>. The last arc is created between the last and first points to close the loop of the polygon. For this reason you do <em>not</em> need to ensure that the first and last points have the same position (although it’s not an error if this is the case because the final arc will then just have a zero length).</p>
<p>It is <em>not</em> an error for adjacent points in the sequence to be coincident. In this case each <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">GreatCircleArc</span></code></a> between two such adjacent points will have zero length (<a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc.is_zero_length" title="pygplates.GreatCircleArc.is_zero_length"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GreatCircleArc.is_zero_length()</span></code></a> will return <code class="docutils literal notranslate"><span class="pre">True</span></code>) and will have no rotation axis (<a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc.get_rotation_axis" title="pygplates.GreatCircleArc.get_rotation_axis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GreatCircleArc.get_rotation_axis()</span></code></a> will raise an error).</p>
<p>The following example shows a few different ways to create a <a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">polygon</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
<span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

<span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lat1</span><span class="p">,</span><span class="n">lon1</span><span class="p">))</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lat2</span><span class="p">,</span><span class="n">lon2</span><span class="p">))</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lat3</span><span class="p">,</span><span class="n">lon3</span><span class="p">))</span>
<span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

<span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">z1</span><span class="p">])</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">z2</span><span class="p">])</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x3</span><span class="p">,</span><span class="n">y3</span><span class="p">,</span><span class="n">z3</span><span class="p">])</span>
<span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
</pre></div>
</div>
<p>If you have latitude/longitude values but they are not a sequence of tuples or if the latitude/longitude order is swapped then the following examples demonstrate how you could restructure them:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Flat lat/lon array.</span>
<span class="n">points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lat1</span><span class="p">,</span> <span class="n">lon1</span><span class="p">,</span> <span class="n">lat2</span><span class="p">,</span> <span class="n">lon2</span><span class="p">,</span> <span class="n">lat3</span><span class="p">,</span> <span class="n">lon3</span><span class="p">])</span>
<span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">points</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]))</span>

<span class="c1"># Flat lon/lat list (ie, different latitude/longitude order).</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">,</span> <span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span><span class="p">,</span> <span class="n">lon3</span><span class="p">,</span> <span class="n">lat3</span><span class="p">]</span>
<span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span><span class="n">points</span><span class="p">[::</span><span class="mi">2</span><span class="p">]))</span>

<span class="c1"># Separate lat/lon arrays.</span>
<span class="n">lats</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lat1</span><span class="p">,</span> <span class="n">lat2</span><span class="p">,</span> <span class="n">lat3</span><span class="p">])</span>
<span class="n">lons</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lon2</span><span class="p">,</span> <span class="n">lon3</span><span class="p">])</span>
<span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span><span class="n">lons</span><span class="p">))</span>

<span class="c1"># Lon/lat list of tuples (ie, different latitude/longitude order).</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[(</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">),</span> <span class="p">(</span><span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span><span class="p">),</span> <span class="p">(</span><span class="n">lon3</span><span class="p">,</span> <span class="n">lat3</span><span class="p">)]</span>
<span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">([(</span><span class="n">lat</span><span class="p">,</span><span class="n">lon</span><span class="p">)</span> <span class="k">for</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="ow">in</span> <span class="n">points</span><span class="p">])</span>
</pre></div>
</div>
</dd>
<dt>__init__(geometry, [allow_one_or_two_points=True])</dt>
<dd><p class="first">Create a polygon from a <a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere" title="pygplates.GeometryOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeometryOnSphere</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param geometry:</th><td class="field-body">The point, multi-point, polyline or polygon geometry to convert from.</td>
</tr>
<tr class="field-even field"><th class="field-name">type geometry:</th><td class="field-body"><a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere" title="pygplates.GeometryOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeometryOnSphere</span></code></a></td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param allow_one_or_two_points:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">Whether <em>geometry</em> is allowed to be a <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> or a <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiPointOnSphere</span></code></a> containing only one or two points - if allowed then one of those points is duplicated since a PolygonOnSphere requires at least three points - default is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type allow_one_or_two_points:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">bool</td>
</tr>
<tr class="field-odd field"><th class="field-name">raises:</th><td class="field-body">InvalidPointsForPolygonConstructionError if <em>geometry</em> is a <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a>, or a <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiPointOnSphere</span></code></a> with one or two points (and <em>allow_one_or_two_points</em> is <code class="docutils literal notranslate"><span class="pre">False</span></code>), or if any two consecutive points in a <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiPointOnSphere</span></code></a> are antipodal to each other (on opposite sides of the globe)</td>
</tr>
</tbody>
</table>
<p>If <em>allow_one_or_two_points</em> is <code class="docutils literal notranslate"><span class="pre">True</span></code> then <em>geometry</em> can be <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a>, <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiPointOnSphere</span></code></a>, <a class="reference internal" href="pygplates.PolylineOnSphere.html#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolylineOnSphere</span></code></a> or <a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolygonOnSphere</span></code></a>. However if <em>allow_one_or_two_points</em> is <code class="docutils literal notranslate"><span class="pre">False</span></code> then <em>geometry</em> must be a <a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolygonOnSphere</span></code></a>, or a <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiPointOnSphere</span></code></a> or <a class="reference internal" href="pygplates.PolylineOnSphere.html#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolylineOnSphere</span></code></a> containing at least three points to avoid raising <em>InvalidPointsForPolygonConstructionError</em>.</p>
<p>During creation, a <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">GreatCircleArc</span></code></a> is created between each adjacent pair of geometry points - see <a class="reference internal" href="#pygplates.PolygonOnSphere.get_segments" title="pygplates.PolygonOnSphere.get_segments"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_segments()</span></code></a>.</p>
<p>It is <em>not</em> an error for adjacent points in a geometry sequence to be coincident. In this case each <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">GreatCircleArc</span></code></a> between two such adjacent points will have zero length (<a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc.is_zero_length" title="pygplates.GreatCircleArc.is_zero_length"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GreatCircleArc.is_zero_length()</span></code></a> will return <code class="docutils literal notranslate"><span class="pre">True</span></code>) and will have no rotation axis (<a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc.get_rotation_axis" title="pygplates.GreatCircleArc.get_rotation_axis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GreatCircleArc.get_rotation_axis()</span></code></a> will raise an error). However if two such adjacent points are antipodal (on opposite sides of the globe) then InvalidPointsForPolygonConstructionError will be raised</p>
<p>To create a PolygonOnSphere from any geometry type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="n">geometry</span><span class="p">)</span>
</pre></div>
</div>
<p>To create a PolygonOnSphere from any geometry containing at least three points:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">allow_one_or_two_points</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">except</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">InvalidPointsForPolygonConstructionError</span><span class="p">:</span>
    <span class="o">...</span> <span class="c1"># Handle failure to convert &#39;geometry&#39; to a PolygonOnSphere.</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.__init__" title="pygplates.PolygonOnSphere.__init__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__init__</span></code></a>(…)</td>
<td>A <em>PolygonOnSphere</em> object can be constructed in more than one way…</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">clone</span></code>()</td>
<td>Create a duplicate of this geometry (derived) instance.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">distance</span></code>(geometry1,&nbsp;geometry2,&nbsp;…)</td>
<td>[<em>staticmethod</em>] Returns the (minimum) distance between two geometries (in radians).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.get_arc_length" title="pygplates.PolygonOnSphere.get_arc_length"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_arc_length</span></code></a>()</td>
<td>Returns the total arc length of this polygon (in radians).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.get_area" title="pygplates.PolygonOnSphere.get_area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_area</span></code></a>()</td>
<td>Returns the area of this polygon (on a sphere of unit radius).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.get_boundary_centroid" title="pygplates.PolygonOnSphere.get_boundary_centroid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_boundary_centroid</span></code></a>()</td>
<td>Returns the <em>boundary</em> centroid of this polygon.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.get_interior_centroid" title="pygplates.PolygonOnSphere.get_interior_centroid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_interior_centroid</span></code></a>()</td>
<td>Returns the <em>interior</em> centroid of this polygon.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.get_orientation" title="pygplates.PolygonOnSphere.get_orientation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_orientation</span></code></a>()</td>
<td>Returns whether this polygon is clockwise or counter-clockwise.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_points</span></code>()</td>
<td>Returns a <em>read-only</em> sequence of <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">points</span></code></a> in this geometry.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.get_segments" title="pygplates.PolygonOnSphere.get_segments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_segments</span></code></a>()</td>
<td>Returns a <em>read-only</em> sequence of <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">segments</span></code></a> in this polygon.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.get_signed_area" title="pygplates.PolygonOnSphere.get_signed_area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_signed_area</span></code></a>()</td>
<td>Returns the <em>signed</em> area of this polygon (on a sphere of unit radius).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.is_point_in_polygon" title="pygplates.PolygonOnSphere.is_point_in_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_point_in_polygon</span></code></a>(point)</td>
<td>Determines whether the specified point lies within the interior of this polygon.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.partition" title="pygplates.PolygonOnSphere.partition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">partition</span></code></a>(geometry,&nbsp;…)</td>
<td>Partition a geometry into optional inside/outside lists of partitioned geometry pieces.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_lat_lon_array</span></code>()</td>
<td>Returns the sequence of points, in this geometry, as a numpy array of (latitude,longitude) pairs (in degrees).</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_lat_lon_list</span></code>()</td>
<td>Returns the sequence of points, in this geometry, as (latitude,longitude) tuples (in degrees).</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_lat_lon_point_list</span></code>()</td>
<td>Returns the sequence of points, in this geometry, as <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><code class="xref py py-class docutils literal notranslate"><span class="pre">lat</span> <span class="pre">lon</span> <span class="pre">points</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pygplates.PolygonOnSphere.to_tessellated" title="pygplates.PolygonOnSphere.to_tessellated"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_tessellated</span></code></a>(tessellate_radians)</td>
<td>Returns a new polygon that is tessellated version of this polygon.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_xyz_array</span></code>()</td>
<td>Returns the sequence of points, in this geometry, as a numpy array of (x,y,z) triplets.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_xyz_list</span></code>()</td>
<td>Returns the sequence of points, in this geometry, as (x,y,z) cartesian coordinate tuples.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="pygplates.PolygonOnSphere.Orientation">
<em class="property">class </em><code class="descname">Orientation</code><a class="headerlink" href="#pygplates.PolygonOnSphere.Orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Boost.Python.enum</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pygplates.PolygonOnSphere.PartitionResult">
<em class="property">class </em><code class="descname">PartitionResult</code><a class="headerlink" href="#pygplates.PolygonOnSphere.PartitionResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Boost.Python.enum</span></code></p>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.get_arc_length">
<code class="descname">get_arc_length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.PolygonOnSphere.get_arc_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total arc length of this polygon (in radians).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line">This is the sum of the arc lengths of the <a class="reference internal" href="#pygplates.PolygonOnSphere.get_segments" title="pygplates.PolygonOnSphere.get_segments"><code class="xref py py-meth docutils literal notranslate"><span class="pre">segments</span></code></a> of this polygon.</div>
<div class="line">To convert to distance, multiply the result by the Earth radius (see <a class="reference internal" href="pygplates.Earth.html#pygplates.Earth" title="pygplates.Earth"><code class="xref py py-class docutils literal notranslate"><span class="pre">Earth</span></code></a>).</div>
</div>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.get_area">
<code class="descname">get_area</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.PolygonOnSphere.get_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the area of this polygon (on a sphere of unit radius).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
<p>The area is essentially the absolute value of the <a class="reference internal" href="#pygplates.PolygonOnSphere.get_signed_area" title="pygplates.PolygonOnSphere.get_signed_area"><code class="xref py py-meth docutils literal notranslate"><span class="pre">signed</span> <span class="pre">area</span></code></a>.</p>
<p>To convert to area on the Earth’s surface, multiply the result by the Earth radius squared (see <a class="reference internal" href="pygplates.Earth.html#pygplates.Earth" title="pygplates.Earth"><code class="xref py py-class docutils literal notranslate"><span class="pre">Earth</span></code></a>).</p>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.get_boundary_centroid">
<code class="descname">get_boundary_centroid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.PolygonOnSphere.get_boundary_centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <em>boundary</em> centroid of this polygon.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a></td>
</tr>
</tbody>
</table>
<p>The <em>boundary</em> centroid is calculated as a weighted average of the mid-points of the <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">great</span> <span class="pre">circle</span> <span class="pre">arcs</span></code></a> of this polygon with weighting proportional to the individual arc lengths.</p>
<p>Note that if you want a centroid closer to the centre-of-mass of the polygon interior then use <a class="reference internal" href="#pygplates.PolygonOnSphere.get_interior_centroid" title="pygplates.PolygonOnSphere.get_interior_centroid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_interior_centroid()</span></code></a> instead.</p>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.get_interior_centroid">
<code class="descname">get_interior_centroid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.PolygonOnSphere.get_interior_centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <em>interior</em> centroid of this polygon.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a></td>
</tr>
</tbody>
</table>
<p>The <em>interior</em> centroid is calculated as a weighted average of the centroids of spherical triangles formed by the <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">great</span> <span class="pre">circle</span> <span class="pre">arcs</span></code></a> of this polygon and its (boundary) centroid with weighting proportional to the signed area of each individual spherical triangle. The three vertices of each spherical triangle consist of the polygon (boundary) centroid and the two end points of a great circle arc.</p>
<p>This centroid is useful when the centre-of-mass of the polygon interior is desired. For example, the <em>interior</em> centroid of a bottom-heavy, pear-shaped polygon will be closer to the bottom of the polygon. This centroid is not exactly at the centre-of-mass, but it will be a lot closer to the real centre-of-mass than <a class="reference internal" href="#pygplates.PolygonOnSphere.get_boundary_centroid" title="pygplates.PolygonOnSphere.get_boundary_centroid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_boundary_centroid()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.get_orientation">
<code class="descname">get_orientation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.PolygonOnSphere.get_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether this polygon is clockwise or counter-clockwise.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pygplates.PolygonOnSphere.Orientation" title="pygplates.PolygonOnSphere.Orientation">PolygonOnSphere.Orientation</a></td>
</tr>
</tbody>
</table>
<p>If this polygon is clockwise (when viewed from above the surface of the sphere) then <em>PolygonOnSphere.Orientation.clockwise</em> is returned, otherwise <em>PolygonOnSphere.Orientation.counter_clockwise</em> is returned.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">polygon</span><span class="o">.</span><span class="n">get_orientation</span><span class="p">()</span> <span class="o">==</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="o">.</span><span class="n">Orientation</span><span class="o">.</span><span class="n">clockwise</span><span class="p">:</span>
  <span class="nb">print</span> <span class="s1">&#39;Orientation is clockwise&#39;</span>
<span class="k">else</span><span class="p">:</span>
  <span class="nb">print</span> <span class="s1">&#39;Orientation is counter-clockwise&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.get_segments">
<code class="descname">get_segments</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.PolygonOnSphere.get_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <em>read-only</em> sequence of <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">segments</span></code></a> in this polygon.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">a read-only sequence of <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">GreatCircleArc</span></code></a></td>
</tr>
</tbody>
</table>
<p>The following operations for accessing the great circle arcs in the returned read-only sequence are supported:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Operation</th>
<th class="head">Result</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">len(seq)</span></code></td>
<td>number of segments of the polygon</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">s</span> <span class="pre">in</span> <span class="pre">seq</span></code></td>
<td>iterates over the segments <em>s</em> of the polygon</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">in</span> <span class="pre">seq</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>s</em> is an segment of the polygon</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">seq</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">False</span></code> if <em>s</em> is an segment of the polygon</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">seq[i]</span></code></td>
<td>the segment of the polygon at index <em>i</em></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">seq[i:j]</span></code></td>
<td>slice of segments of the polygon from <em>i</em> to <em>j</em></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">seq[i:j:k]</span></code></td>
<td>slice of segments of the polygon from <em>i</em> to <em>j</em> with step <em>k</em></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Between each adjacent pair of <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">points</span></code></a> there is an <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">segment</span></code></a> such that the number of points equals the number of segments.</p>
</div>
<p>The following example demonstrates some uses of the above operations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">polygon</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">segments</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">get_segments</span><span class="p">()</span>
<span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">segment</span><span class="o">.</span><span class="n">is_zero_length</span><span class="p">():</span>
        <span class="n">segment_midpoint_direction</span> <span class="o">=</span> <span class="n">segment</span><span class="o">.</span><span class="n">get_arc_direction</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">first_segment</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">last_segment</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc.get_end_point" title="pygplates.GreatCircleArc.get_end_point"><code class="xref py py-meth docutils literal notranslate"><span class="pre">end</span> <span class="pre">point</span></code></a> of the last segment is equal to the <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc.get_start_point" title="pygplates.GreatCircleArc.get_start_point"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start</span> <span class="pre">point</span></code></a> of the first segment.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned sequence is <em>read-only</em> and cannot be modified.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you want a modifiable sequence consider wrapping the returned sequence in a <code class="docutils literal notranslate"><span class="pre">list</span></code> using something like <code class="docutils literal notranslate"><span class="pre">segments</span> <span class="pre">=</span> <span class="pre">list(polygon.get_segments())</span></code> <strong>but</strong> note that modifying the <code class="docutils literal notranslate"><span class="pre">list</span></code> (eg, appending a new segment) will <strong>not</strong> modify the original polygon.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.get_signed_area">
<code class="descname">get_signed_area</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.PolygonOnSphere.get_signed_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <em>signed</em> area of this polygon (on a sphere of unit radius).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
<p>If this polygon is clockwise (when viewed from above the surface of the sphere) then the returned area will be negative, otherwise it will be positive. However if you only want to determine the orientation of this polygon then <a class="reference internal" href="#pygplates.PolygonOnSphere.get_orientation" title="pygplates.PolygonOnSphere.get_orientation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_orientation()</span></code></a> is more efficient than comparing the sign of the area.</p>
<p>To convert to <em>signed</em> area on the Earth’s surface, multiply the result by the Earth radius squared (see <a class="reference internal" href="pygplates.Earth.html#pygplates.Earth" title="pygplates.Earth"><code class="xref py py-class docutils literal notranslate"><span class="pre">Earth</span></code></a>).</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#pygplates.PolygonOnSphere.get_area" title="pygplates.PolygonOnSphere.get_area"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_area()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.is_point_in_polygon">
<code class="descname">is_point_in_polygon</code><span class="sig-paren">(</span><em>point</em><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.PolygonOnSphere.is_point_in_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines whether the specified point lies within the interior of this polygon.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>point</strong> (<a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> or <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><code class="xref py py-class docutils literal notranslate"><span class="pre">LatLonPoint</span></code></a> or (latitude,longitude), in degrees, or (x,y,z)) – the point to be tested</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
<p>Test if a (latitude, longitude) point is inside a polygon:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">polygon</span><span class="o">.</span><span class="n">is_point_in_polygon</span><span class="p">((</span><span class="n">latitude</span><span class="p">,</span> <span class="n">longitude</span><span class="p">)):</span>
  <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.partition">
<code class="descname">partition</code><span class="sig-paren">(</span><em>geometry</em><span class="optional">[</span>, <em>partitioned_geometries_inside</em><span class="optional">]</span><span class="optional">[</span>, <em>partitioned_geometries_outside</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.PolygonOnSphere.partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Partition a geometry into optional inside/outside lists of partitioned geometry pieces.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geometry</strong> (<a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere" title="pygplates.GeometryOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeometryOnSphere</span></code></a>) – the geometry to be partitioned</li>
<li><strong>partitioned_geometries_inside</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere" title="pygplates.GeometryOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeometryOnSphere</span></code></a>, or None) – optional list of geometries partitioned <em>inside</em> this polygon (note that the list is <em>not</em> cleared first)</li>
<li><strong>partitioned_geometries_outside</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere" title="pygplates.GeometryOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeometryOnSphere</span></code></a>, or None) – optional list of geometries partitioned <em>outside</em> this polygon (note that the list is <em>not</em> cleared first)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pygplates.PolygonOnSphere.PartitionResult" title="pygplates.PolygonOnSphere.PartitionResult">PolygonOnSphere.PartitionResult</a></p>
</td>
</tr>
</tbody>
</table>
<p>The returned result is:</p>
<ul class="simple">
<li><em>PolygonOnSphere.PartitionResult.inside</em>: if <em>geometry</em> is entirely <em>inside</em> this polygon, or</li>
<li><em>PolygonOnSphere.PartitionResult.outside</em>: if <em>geometry</em> is entirely <em>outside</em> this polygon, or</li>
<li><em>PolygonOnSphere.PartitionResult.intersecting</em>: if <em>geometry</em> <em>intersects</em> this polygon.</li>
</ul>
<p>If <em>partitioned_geometries_inside</em> is specified then it must be a <code class="docutils literal notranslate"><span class="pre">list</span></code> and any part of <em>geometry</em> inside this polygon is added to it. So if <em>PolygonOnSphere.PartitionResult.inside</em> is returned this means <em>geometry</em> is added and if <em>PolygonOnSphere.PartitionResult.intersecting</em> is returned this means the partitioned parts of <em>geometry</em> inside this polygon are added.</p>
<p>If <em>partitioned_geometries_outside</em> is specified then if must be a <code class="docutils literal notranslate"><span class="pre">list</span></code> and any part of <em>geometry</em> outside this polygon is added to it. So if <em>PolygonOnSphere.PartitionResult.outside</em> is returned this means <em>geometry</em> is added and if <em>PolygonOnSphere.PartitionResult.intersecting</em> is returned this means the partitioned parts of <em>geometry</em> outside this polygon are added.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Partitioning <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">point</span></code></a> geometries returns only <em>PolygonOnSphere.PartitionResult.inside</em> or <em>PolygonOnSphere.PartitionResult.outside</em>.</p>
</div>
<p>If a partitioned <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">multi-point</span></code></a> contains points both inside and outside this polygon then <em>PolygonOnSphere.PartitionResult.intersecting</em> is returned. In this case the points <em>inside</em> are added as a single <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiPointOnSphere</span></code></a> to <em>partitioned_geometries_inside</em> (if specified) and the points <em>outside</em> are added as a single <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiPointOnSphere</span></code></a> to <em>partitioned_geometries_outside</em> (if specified).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<div class="last line-block">
<div class="line">Support for partitioning a <a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">polygon</span></code></a> geometry is partial.</div>
<div class="line">If a polygon geometry is entirely inside or entirely outside this polygon then it will get added as a <strong>polygon</strong> as expected (to <em>partitioned_geometries_inside</em> or <em>partitioned_geometries_outside</em> respectively if specified).</div>
<div class="line">But if a polygon geometry intersects this polygon, then partitioned <strong>polylines</strong> (not polygons) are added (to the optional inside/outside lists).</div>
<div class="line">This is also how it is in the Assign Plate IDs dialog in <a class="reference external" href="http://www.gplates.org">GPlates</a>.</div>
<div class="line"><em>In a future release this will be fixed to always return polygons.</em></div>
</div>
</div>
<p>Test if a polyline is entirely inside a polygon:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">polygon</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">polyline</span><span class="p">)</span> <span class="o">==</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolygonOnSphere</span><span class="o">.</span><span class="n">PartitionResult</span><span class="o">.</span><span class="n">inside</span><span class="p">:</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>Find the bits of a polyline that are outside a group of continental polygons:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Start with the original polyline to partition.</span>
<span class="n">oceanic_polylines</span> <span class="o">=</span> <span class="p">[</span><span class="n">polyline</span><span class="p">]</span>

<span class="k">for</span> <span class="n">continental_polygon</span> <span class="ow">in</span> <span class="n">continental_polygons</span><span class="p">:</span>
    <span class="c1"># Iterate over the polylines that are outside the continental polygons processed so far.</span>
    <span class="n">current_oceanic_polylines</span> <span class="o">=</span> <span class="n">oceanic_polylines</span>
    <span class="c1"># The new list of polylines will also be outside the current continental polygon.</span>
    <span class="n">oceanic_polylines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">current_oceanic_polyline</span> <span class="ow">in</span> <span class="n">current_oceanic_polylines</span><span class="p">:</span>
        <span class="n">continental_polygon</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">current_oceanic_polyline</span><span class="p">,</span> <span class="n">partitioned_geometries_outside</span><span class="o">=</span><span class="n">oceanic_polylines</span><span class="p">)</span>

<span class="c1"># The final result is in &#39;oceanic_polylines&#39;.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pygplates.PolygonOnSphere.to_tessellated">
<code class="descname">to_tessellated</code><span class="sig-paren">(</span><em>tessellate_radians</em><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.PolygonOnSphere.to_tessellated" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new polygon that is tessellated version of this polygon.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tessellate_radians</strong> (<em>float</em>) – maximum tessellation angle (in radians)</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolygonOnSphere</span></code></a></td>
</tr>
</tbody>
</table>
<p>Adjacent points (in the returned tessellated polygon) are separated by no more than <em>tessellate_radians</em> on the globe.</p>
<p>Create a polygon tessellated to 2 degrees:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tessellated_polygon</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">to_tessellated</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Since a <em>PolygonOnSphere</em> is immutable it cannot be modified. Which is why a new (tessellated) <em>PolygonOnSphere</em> is returned.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The distance between adjacent points (in the tessellated polygon) will not be exactly <em>uniform</em>. This is because each <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">segment</span></code></a> in the original polygon is tessellated to the nearest integer number of points (that keeps that segment under the threshold) and hence each original <em>segment</em> will have a slightly different tessellation angle.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc.to_tessellated" title="pygplates.GreatCircleArc.to_tessellated"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GreatCircleArc.to_tessellated()</span></code></a></p>
</div>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="pygplates.PolylineOnSphere.html"
                        title="previous chapter">pygplates.PolylineOnSphere</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pygplates.GeometryOnSphere.html"
                        title="next chapter">pygplates.GeometryOnSphere</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/generated/pygplates.PolygonOnSphere.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="pygplates.GeometryOnSphere.html" title="pygplates.GeometryOnSphere"
             >next</a> |</li>
        <li class="right" >
          <a href="pygplates.PolylineOnSphere.html" title="pygplates.PolylineOnSphere"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">pygplates 2.2.0.28 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../pygplates_reference.html" >Reference</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright (C) 2003-2020 The University of Sydney, Australia
(C) 2004-2020 California Institute of Technology
(C) 2007-2020 The Geological Survey of Norway
.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>